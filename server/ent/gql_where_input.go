// Code generated by ent, DO NOT EDIT.

package ent

import (
	"dax/server/ent/entry"
	"dax/server/ent/predicate"
	"dax/server/ent/user"
	"dax/server/ent/vault"
	"errors"
	"fmt"
	"time"
)

// EntryWhereInput represents a where input for filtering Entry queries.
type EntryWhereInput struct {
	Predicates []predicate.Entry  `json:"-"`
	Not        *EntryWhereInput   `json:"not,omitempty"`
	Or         []*EntryWhereInput `json:"or,omitempty"`
	And        []*EntryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "heading" field predicates.
	Heading             *string  `json:"heading,omitempty"`
	HeadingNEQ          *string  `json:"headingNEQ,omitempty"`
	HeadingIn           []string `json:"headingIn,omitempty"`
	HeadingNotIn        []string `json:"headingNotIn,omitempty"`
	HeadingGT           *string  `json:"headingGT,omitempty"`
	HeadingGTE          *string  `json:"headingGTE,omitempty"`
	HeadingLT           *string  `json:"headingLT,omitempty"`
	HeadingLTE          *string  `json:"headingLTE,omitempty"`
	HeadingContains     *string  `json:"headingContains,omitempty"`
	HeadingHasPrefix    *string  `json:"headingHasPrefix,omitempty"`
	HeadingHasSuffix    *string  `json:"headingHasSuffix,omitempty"`
	HeadingIsNil        bool     `json:"headingIsNil,omitempty"`
	HeadingNotNil       bool     `json:"headingNotNil,omitempty"`
	HeadingEqualFold    *string  `json:"headingEqualFold,omitempty"`
	HeadingContainsFold *string  `json:"headingContainsFold,omitempty"`

	// "body" field predicates.
	Body             *string  `json:"body,omitempty"`
	BodyNEQ          *string  `json:"bodyNEQ,omitempty"`
	BodyIn           []string `json:"bodyIn,omitempty"`
	BodyNotIn        []string `json:"bodyNotIn,omitempty"`
	BodyGT           *string  `json:"bodyGT,omitempty"`
	BodyGTE          *string  `json:"bodyGTE,omitempty"`
	BodyLT           *string  `json:"bodyLT,omitempty"`
	BodyLTE          *string  `json:"bodyLTE,omitempty"`
	BodyContains     *string  `json:"bodyContains,omitempty"`
	BodyHasPrefix    *string  `json:"bodyHasPrefix,omitempty"`
	BodyHasSuffix    *string  `json:"bodyHasSuffix,omitempty"`
	BodyIsNil        bool     `json:"bodyIsNil,omitempty"`
	BodyNotNil       bool     `json:"bodyNotNil,omitempty"`
	BodyEqualFold    *string  `json:"bodyEqualFold,omitempty"`
	BodyContainsFold *string  `json:"bodyContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "vault" edge predicates.
	HasVault     *bool              `json:"hasVault,omitempty"`
	HasVaultWith []*VaultWhereInput `json:"hasVaultWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EntryWhereInput) AddPredicates(predicates ...predicate.Entry) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EntryWhereInput filter on the EntryQuery builder.
func (i *EntryWhereInput) Filter(q *EntryQuery) (*EntryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEntryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEntryWhereInput is returned in case the EntryWhereInput is empty.
var ErrEmptyEntryWhereInput = errors.New("ent: empty predicate EntryWhereInput")

// P returns a predicate for filtering entries.
// An error is returned if the input is empty or invalid.
func (i *EntryWhereInput) P() (predicate.Entry, error) {
	var predicates []predicate.Entry
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, entry.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Entry, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, entry.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Entry, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, entry.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, entry.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, entry.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, entry.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, entry.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, entry.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, entry.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, entry.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, entry.IDLTE(*i.IDLTE))
	}
	if i.Heading != nil {
		predicates = append(predicates, entry.HeadingEQ(*i.Heading))
	}
	if i.HeadingNEQ != nil {
		predicates = append(predicates, entry.HeadingNEQ(*i.HeadingNEQ))
	}
	if len(i.HeadingIn) > 0 {
		predicates = append(predicates, entry.HeadingIn(i.HeadingIn...))
	}
	if len(i.HeadingNotIn) > 0 {
		predicates = append(predicates, entry.HeadingNotIn(i.HeadingNotIn...))
	}
	if i.HeadingGT != nil {
		predicates = append(predicates, entry.HeadingGT(*i.HeadingGT))
	}
	if i.HeadingGTE != nil {
		predicates = append(predicates, entry.HeadingGTE(*i.HeadingGTE))
	}
	if i.HeadingLT != nil {
		predicates = append(predicates, entry.HeadingLT(*i.HeadingLT))
	}
	if i.HeadingLTE != nil {
		predicates = append(predicates, entry.HeadingLTE(*i.HeadingLTE))
	}
	if i.HeadingContains != nil {
		predicates = append(predicates, entry.HeadingContains(*i.HeadingContains))
	}
	if i.HeadingHasPrefix != nil {
		predicates = append(predicates, entry.HeadingHasPrefix(*i.HeadingHasPrefix))
	}
	if i.HeadingHasSuffix != nil {
		predicates = append(predicates, entry.HeadingHasSuffix(*i.HeadingHasSuffix))
	}
	if i.HeadingIsNil {
		predicates = append(predicates, entry.HeadingIsNil())
	}
	if i.HeadingNotNil {
		predicates = append(predicates, entry.HeadingNotNil())
	}
	if i.HeadingEqualFold != nil {
		predicates = append(predicates, entry.HeadingEqualFold(*i.HeadingEqualFold))
	}
	if i.HeadingContainsFold != nil {
		predicates = append(predicates, entry.HeadingContainsFold(*i.HeadingContainsFold))
	}
	if i.Body != nil {
		predicates = append(predicates, entry.BodyEQ(*i.Body))
	}
	if i.BodyNEQ != nil {
		predicates = append(predicates, entry.BodyNEQ(*i.BodyNEQ))
	}
	if len(i.BodyIn) > 0 {
		predicates = append(predicates, entry.BodyIn(i.BodyIn...))
	}
	if len(i.BodyNotIn) > 0 {
		predicates = append(predicates, entry.BodyNotIn(i.BodyNotIn...))
	}
	if i.BodyGT != nil {
		predicates = append(predicates, entry.BodyGT(*i.BodyGT))
	}
	if i.BodyGTE != nil {
		predicates = append(predicates, entry.BodyGTE(*i.BodyGTE))
	}
	if i.BodyLT != nil {
		predicates = append(predicates, entry.BodyLT(*i.BodyLT))
	}
	if i.BodyLTE != nil {
		predicates = append(predicates, entry.BodyLTE(*i.BodyLTE))
	}
	if i.BodyContains != nil {
		predicates = append(predicates, entry.BodyContains(*i.BodyContains))
	}
	if i.BodyHasPrefix != nil {
		predicates = append(predicates, entry.BodyHasPrefix(*i.BodyHasPrefix))
	}
	if i.BodyHasSuffix != nil {
		predicates = append(predicates, entry.BodyHasSuffix(*i.BodyHasSuffix))
	}
	if i.BodyIsNil {
		predicates = append(predicates, entry.BodyIsNil())
	}
	if i.BodyNotNil {
		predicates = append(predicates, entry.BodyNotNil())
	}
	if i.BodyEqualFold != nil {
		predicates = append(predicates, entry.BodyEqualFold(*i.BodyEqualFold))
	}
	if i.BodyContainsFold != nil {
		predicates = append(predicates, entry.BodyContainsFold(*i.BodyContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, entry.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, entry.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, entry.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, entry.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, entry.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, entry.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, entry.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, entry.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, entry.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, entry.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, entry.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, entry.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, entry.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, entry.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, entry.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, entry.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, entry.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, entry.UpdatedAtNotNil())
	}

	if i.HasVault != nil {
		p := entry.HasVault()
		if !*i.HasVault {
			p = entry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVaultWith) > 0 {
		with := make([]predicate.Vault, 0, len(i.HasVaultWith))
		for _, w := range i.HasVaultWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVaultWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, entry.HasVaultWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEntryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return entry.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "active_at" field predicates.
	ActiveAt       *time.Time  `json:"activeAt,omitempty"`
	ActiveAtNEQ    *time.Time  `json:"activeAtNEQ,omitempty"`
	ActiveAtIn     []time.Time `json:"activeAtIn,omitempty"`
	ActiveAtNotIn  []time.Time `json:"activeAtNotIn,omitempty"`
	ActiveAtGT     *time.Time  `json:"activeAtGT,omitempty"`
	ActiveAtGTE    *time.Time  `json:"activeAtGTE,omitempty"`
	ActiveAtLT     *time.Time  `json:"activeAtLT,omitempty"`
	ActiveAtLTE    *time.Time  `json:"activeAtLTE,omitempty"`
	ActiveAtIsNil  bool        `json:"activeAtIsNil,omitempty"`
	ActiveAtNotNil bool        `json:"activeAtNotNil,omitempty"`

	// "vaults" edge predicates.
	HasVaults     *bool              `json:"hasVaults,omitempty"`
	HasVaultsWith []*VaultWhereInput `json:"hasVaultsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, user.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, user.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, user.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, user.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, user.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, user.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, user.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, user.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, user.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, user.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, user.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, user.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, user.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Hash != nil {
		predicates = append(predicates, user.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, user.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, user.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, user.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, user.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, user.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, user.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, user.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, user.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, user.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, user.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, user.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, user.HashContainsFold(*i.HashContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.ActiveAt != nil {
		predicates = append(predicates, user.ActiveAtEQ(*i.ActiveAt))
	}
	if i.ActiveAtNEQ != nil {
		predicates = append(predicates, user.ActiveAtNEQ(*i.ActiveAtNEQ))
	}
	if len(i.ActiveAtIn) > 0 {
		predicates = append(predicates, user.ActiveAtIn(i.ActiveAtIn...))
	}
	if len(i.ActiveAtNotIn) > 0 {
		predicates = append(predicates, user.ActiveAtNotIn(i.ActiveAtNotIn...))
	}
	if i.ActiveAtGT != nil {
		predicates = append(predicates, user.ActiveAtGT(*i.ActiveAtGT))
	}
	if i.ActiveAtGTE != nil {
		predicates = append(predicates, user.ActiveAtGTE(*i.ActiveAtGTE))
	}
	if i.ActiveAtLT != nil {
		predicates = append(predicates, user.ActiveAtLT(*i.ActiveAtLT))
	}
	if i.ActiveAtLTE != nil {
		predicates = append(predicates, user.ActiveAtLTE(*i.ActiveAtLTE))
	}
	if i.ActiveAtIsNil {
		predicates = append(predicates, user.ActiveAtIsNil())
	}
	if i.ActiveAtNotNil {
		predicates = append(predicates, user.ActiveAtNotNil())
	}

	if i.HasVaults != nil {
		p := user.HasVaults()
		if !*i.HasVaults {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVaultsWith) > 0 {
		with := make([]predicate.Vault, 0, len(i.HasVaultsWith))
		for _, w := range i.HasVaultsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVaultsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasVaultsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// VaultWhereInput represents a where input for filtering Vault queries.
type VaultWhereInput struct {
	Predicates []predicate.Vault  `json:"-"`
	Not        *VaultWhereInput   `json:"not,omitempty"`
	Or         []*VaultWhereInput `json:"or,omitempty"`
	And        []*VaultWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "entries" edge predicates.
	HasEntries     *bool              `json:"hasEntries,omitempty"`
	HasEntriesWith []*EntryWhereInput `json:"hasEntriesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *VaultWhereInput) AddPredicates(predicates ...predicate.Vault) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the VaultWhereInput filter on the VaultQuery builder.
func (i *VaultWhereInput) Filter(q *VaultQuery) (*VaultQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyVaultWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyVaultWhereInput is returned in case the VaultWhereInput is empty.
var ErrEmptyVaultWhereInput = errors.New("ent: empty predicate VaultWhereInput")

// P returns a predicate for filtering vaults.
// An error is returned if the input is empty or invalid.
func (i *VaultWhereInput) P() (predicate.Vault, error) {
	var predicates []predicate.Vault
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, vault.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Vault, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, vault.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Vault, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, vault.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, vault.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vault.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vault.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vault.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vault.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vault.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vault.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vault.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, vault.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, vault.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, vault.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, vault.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, vault.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, vault.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, vault.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, vault.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, vault.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, vault.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, vault.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, vault.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, vault.NameContainsFold(*i.NameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, vault.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, vault.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, vault.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, vault.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, vault.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, vault.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, vault.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, vault.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasUsers != nil {
		p := vault.HasUsers()
		if !*i.HasUsers {
			p = vault.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, vault.HasUsersWith(with...))
	}
	if i.HasEntries != nil {
		p := vault.HasEntries()
		if !*i.HasEntries {
			p = vault.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntriesWith) > 0 {
		with := make([]predicate.Entry, 0, len(i.HasEntriesWith))
		for _, w := range i.HasEntriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEntriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, vault.HasEntriesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyVaultWhereInput
	case 1:
		return predicates[0], nil
	default:
		return vault.And(predicates...), nil
	}
}
